--- GLOBALS ---

-> console
-> __dirname -> get the path of the current directory
-> __filename -> get the path AND the name of the current file
-> process.argv > returns an array:
	0 -> path to node.exe
	1 -> path to current file + file name
	1+ -> all other params entered after that as a separate element, except in ""

-> process.stdout.write -> writes to the console -> no new lines natively --> can write only strings and buffers NO OBJECTS
-> process.stdout.clearLine() -> deletes the current line;
-> process.stdout.cursorTo(0) -> starts writing from the start of the line

-> process.stdin.on('data', function(data){}) ---> does not end process -> listens for input and fires the event when "enter"
	-> "data" is the data from input, but use .toString().trim();

-> process.exit() -> kills the process
-> process.on('exit', function() {}) ---> do stuff right before the process ends
-> setInterval -> standard
-> setTimeout -> standard
-> var myInterval = setInterval()
	clearInterval(interval) -> kills the setInterval

-> var a = require('path') => loads the 'path' module and assigns it to 'a'

-> var readline = require('readline') => loads readline module -> stdin and stdout wrapper
	-> let rl = readline.createInterface(process.stdin, process.stdout) --> creates an instance
	-> rl.question('question', function(answer){}) -> asks a question once and listens for answer
	-> rl.setPrompt('another question') -> sets up a question to be asked multiple times
	-> rl.prompt() -> asks the set question
	-> rl.on('line', function(input){}) -> used to listen for inputs on prompts
	-> rl.on('close', function(){}) -> used to listed for closing of realine
	-> rl.close() -> stops listening


--- EVENTS ---


-> var events = require('events') --> loads events module; can be used in two ways
	1. let emitter = new events.EventEmitter(); -> creates instance and emitter.on() + emitter.emit();
	2. let EventEmitter = require('events').EventEmitter -> gets the class, not an instance
-> event emitter can raise and listen for custom events
	-> emitter.on('awesomeEvent', function(message, status){})
	-> emitter.emit('awesomeEvent', 'message', 'status')
-> can attach emitter fuctionality to any custom class
	1. let EventEmitter = require('events').EventEmitter
	2. let util = require('util');
	3. create custom class (Person)
	4. util.inherits(Person, EventEmitter) -> Person inherits EventEmitter --> very cool
	5. now every instance of person can .on(...) AND .emit(....)
	-> !!! every .emit <-> .on is linked to the specific instance -> gosho.emit('talk') will trigger only gosho.on('talk') NOT stamat.on('talk')


--- MODULES ---


-> require -> inserts a node module in the current module
	-> var coolness = required('path-to-module');
	-> module.exports = coolness
-> module.exports
	-> can export a class -> module.exports = Person; ---> require receives the class and a new instance can be created
	-> can export an instance -> module.exports = new Person() -> require receives the instance and work with it
	-> can export object:
		-> module.exports = {Person: Person, Name: 'lala'}
		-> use: let a = require() --> a.Name ---> let newInst = new a.Person();

-> exec -> used to execute other processes in our environment -> think of it a way to execute terminal commands
	1. let exec = require('chil_process').exec;
	2. exec('node -v', function(err, result){//...})
	-> used for single async process like 'node -v'

-> spawn -> used for heavier, repetitve child commands
	1. let spawn = require('child_process').spawn;
	2. let childProcess = spawn('node', ['params']) -> first is command name, in array -> everything after the command name
	-> get output data from child -> childProcess.stdout.on('data', function(data){//..})
	-> write data to child -> childProcess.stdin.write('string')
	-> listen for child events -> childProcess.on('eventName', function(){//..})
		-> possible case -> 'exit'


--- FILES SYSTEM ---

-> get the file system module -> let fs = required('fs'); // can do everything with the file system

-> read a directory
	-> get the module
	-> Option (A) ->let files = fs.readdirSync('directory'); // SYNC call -> blocking request -> good only for init configs
	-> Option (B) -> fs.readdir('./lib', (err, data) => {//....}); // ASYNC CALL -> use this
	-> can be wrapped in promise -> const filesPromise = () => {

    						return new Promise((resolve, reject) => {

        						fs.readdir('path-to-directory', (err, data) => {

            							if (err) {
                							reject(err);
            							} else {
                							resolve(data);
            							}

        						});
    						});
					};
	filesPromise().then((data) => {//..}).catch((err) => {//..});


-> read the contents of a file
	-> same as above
	-> fs.readFile('path-to-file', 'UTF-8', (err, data) => {//..}); // there is Sync version of the command
	-> let stats = fs.statSync('filename.withExtension'); -> stats.isFile() -> checks if file


-> create and append files
	-> let fs = require('fs')
	-> get/create a string (contents for the file)
	-> fs.writeFile('fileName.withExtension', mycontentsFile, (err) => {//..}) -> creates the file and fires the callback, if erro -> passes the error


	-> fs.appendFile('name-of-file', contents);

-> create directory
	-> let fs = require('fs');
	-> fs.mkdir('name', (err) => {//...}); -> executes when ready (ASYNC) and passes err obj if error
	-> fs.existsSync('name') -> checks if directory with this name exists -> returns bool

-> rename and move files
	-> let fs = require('fs');
	-> fs.rename('path-to-file', 'new-path-to-file', (err) => {//..}) -> can be sync action
		-> if you keep the same directory -> will rename
		-> if you give a new directory -> will move (and) rename
	
	-> fs.unlink('path-to-file', (err) => {//..}) -> deletes a file, there is a sync option


-> move and delete directories
	-> let fs = require('fs');
	-> fs.rename('dir-path', 'new-dir-path', (err) => {//..}) -> move or rename a directory, can be Sync
	-> fs.rmdir('dir-path', (err) => {//..}) -> deletes a directory // cannot delete a non-empty directory

-> read stream -> used to process large files
	-> let fs = require('fs');
	-> let stream = fs.createReadStream('path-to-file', 'UTF-8');
	-> stream.once('data', () => {//..}) -> invoked once when data is read (at the start)
	-> stream.on('data', (dataBite) => {//..}) -> processes 16 bit information??
	-> stream.on('end', () => {//..}) -> invoked once when finished reading

-> write stream -> used to write large data to files
	-> let fs = require('fs');
	-> let stream = fs.createWriteStream('path-to-file'); // opens stream connection
	-> stream.write('content');
	-> stream.close(); // closes the stream connection








